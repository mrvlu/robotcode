#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    rightPot,       sensorPotentiometer)
#pragma config(Sensor, in5,    autoSelect,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  cubeIntake,     sensorDigitalOut)
#pragma config(Sensor, dgtl2,  skyriseClaw,    sensorDigitalOut)
#pragma config(Sensor, dgtl3,  skyriseArm,     sensorDigitalOut)
#pragma config(Sensor, I2C_1,  backLeftEnc,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  backRightEnc,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           botLeft,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           midLeft,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           midRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           topLeft,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           topRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port7,           frontLeft,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           backRight,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          botRight,      tmotorVex393_HBridge, openLoop)
#include "states.h"
//#include "pid.h"
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
const int fullPower = 127; //full speed
const int skyrise = 60; //for skyrise turn speed
const int rotVal = 425;
const int zero = 0;
const int skyHgt = 200;
int power = 0;
int error = 0;
int intrg = 0;		//integral
int mI = 1;			//integral multiplyer
int mS = 1;			//speed multiplyer
int mIV = 0;		//maximum integral value
int mEV = 100;		//max encoder value
int lastTime = 0;	//last integral check

void clawIntake(clawPos pos){
	switch(pos){
		case OPEN:
		SensorValue[skyriseClaw] = 1;
		break;
		case CLOSED:
		SensorValue[skyriseClaw] = 0;
		break;
}
}

void drive(int power, moveDir dir){
	switch(dir){
	case FORWARDS:
		motor[frontRight] = fullPower * power;
		motor[backRight] = fullPower * power;
		motor[backLeft] = fullPower * power;
		motor[frontLeft] = fullPower * power;
		break;
	case RIGHT:
		motor[frontRight] = -fullPower * power;
		motor[backRight] = fullPower * power;
		motor[backLeft] = -fullPower * power;
		motor[frontLeft] = fullPower * power;
		break;
	case BACKWARDS:
		motor[frontRight] =  fullPower * power;
		motor[backRight] = fullPower * power;
		motor[backLeft] = fullPower * power;
		motor[frontLeft] = fullPower * power;
		break;
	case LEFT:
		motor[frontRight] = fullPower * power;
		motor[backRight] = -fullPower * power;
		motor[backLeft] = fullPower * power;
		motor[frontLeft] = -fullPower * power;
		break;
	}
}

void encDrive(int x){
	nMotorEncoder[backRight] = x;
	nMotorEncoder[backLeft] = x;
	nMotorEncoder[frontRight] = x;
	nMotorEncoder[frontLeft] = x;

}
void rotate(int power, moveDir dir, int encoder){
	encDrive(0);
	while(abs(nMotorEncoder[backRight]) < encoder && abs(nMotorEncoder[backLeft]) < encoder){		//
		switch(dir){
		case LEFT:
			motor[frontRight] = -skyrise;
			motor[backRight] = -skyrise;
			motor[backLeft] =  skyrise;
			motor[frontLeft] =  skyrise;
			break;
		case RIGHT:
			motor[frontRight] =  skyrise;
			motor[backRight] = skyrise;
			motor[backLeft] = -skyrise;
			motor[frontLeft] = -skyrise;
			break;
		}
	}
}

void stopDrive(){
			motor[frontRight] = zero;
			motor[backRight] = zero;
			motor[backLeft] =  zero;
			motor[frontLeft] =  zero;

	}


void encArm(int x){

	nMotorEncoder[topLeft] = x;
	nMotorEncoder[topRight] = x;

}

void intakeControl(clawPos pos) {
	SensorValue[cubeIntake] = pos; //OPEN OR CLOSE
}

void lcdDisplay(){
	while(true){
		//LCD DISPLAY CODE
		bLCDBacklight = true;
		//clear top line
		clearLCDLine(0);
		//clear bottom line
		clearLCDLine(1);
		//set lcd positon to top right
		displayLCDPos(0,0);
		//print
		displayNextLCDString("RIGHT: ");
		//set to bottem left
		displayLCDPos(1,0);
		//print
		displayNextLCDString("LEFT: ");
		//displays potentiometer value
		displayNextLCDNumber(abs(nMotorEncoder(backRight)));
		//sets position
		displayLCDPos(0,6);
		//displays sensor value

		displayNextLCDNumber(abs(nMotorEncoder(backLeft)));
	}

}


void armLeft(int power, armDir dir){
	switch(dir){
	case UP:
		//Left
		motor[topLeft] = fullPower * power;
		motor[midLeft] = fullPower * power;
		motor[botLeft] = fullPower * power;
		break;
	case DOWN:
		//Left
		motor[topLeft] = -fullPower * power;
		motor[midLeft] = -fullPower * power;
		motor[botLeft] = -fullPower * power;
		break;
	}
}
void armRight(int power, armDir dir){
	switch(dir){
	case UP:
		//Right
		motor[topRight] = fullPower * power;
		motor[botRight] = fullPower * power;
		motor[midRight] = fullPower * power;
		break;
	case DOWN:
		//Right
		motor[topRight] = -fullPower * power;
		motor[midRight] = -fullPower * power;
		motor[botRight] = -fullPower * power;
		break;
	}
}

void arm(int power, armDir dir, int changeEnc){
	encArm(0);
while(abs(nMotorEncoder[topLeft]) < changeEnc && abs(nMotorEncoder[topRight]) < changeEnc){
		switch(dir){
		case UP:
			motor[botRight] = -fullPower * power;
			motor[botLeft] = -fullPower * power;
			motor[midRight] = -fullPower * power;
			motor[midLeft] = -fullPower * power;
			motor[topRight] = -fullPower * power;
			motor[topLeft] = -fullPower * power;
			break;
		case DOWN:
			motor[botRight] = fullPower * power;
			motor[botLeft] =  fullPower * power;
			motor[midRight] =  fullPower * power;
			motor[midLeft] =  fullPower * power;
			motor[topRight] =  fullPower * power;
			motor[topLeft] =  fullPower * power;
			break;
		}
	}
}

void pidArm(armDir dir, int dist){
	//2 arm encoders
	lastTime = time1(T1);

	while(nMotorEncoder[left] >= dist &&nMotorEncoder[right] >= dist){
		int checkValue = nMotorEncoder[left] - nMotorEncoder[right];
		switch(dir){
		case UP:
			if(checkValue > 0){
				error = (nMotorEncoder[left] - nMotorEncoder[right])/mEV;
				intrg += error * ((time1(T1) - lastTime) / mI);
				if(-100 < error && error < 100)
					intrg = 0;
				if(abs(intrg) <= mIV)
					intrg = mIV;
				power = error*mS - intrg;
				armRight(1, dir);
				armLeft(1-power, dir);
				}else if(checkValue < 0){
				error = (nMotorEncoder[right] - nMotorEncoder[left])/mEV;
				intrg += error * ((time1(T1) - lastTime) / mI);
				if(-100 < error && error < 100)
					intrg = 0;
				if(abs(intrg) <= mIV)
					intrg = mIV;
				power = error*mS - intrg;
				armLeft(1, dir);
				armRight(1-power, dir);
				}else {
				arm(1,dir,1);
			}
			lastTime = time1(T1);
			break;
		case DOWN:
			checkValue *= -1;
			if(checkValue > 0){
				error = (nMotorEncoder[left] - nMotorEncoder[right])/mEV;
				intrg += error * ((time1(T1) - lastTime) / mI);
				if(-100 < error && error < 100)
					intrg = 0;
				if(abs(intrg) <= mIV)
					intrg = mIV;
				power = error*mS - intrg;
				armRight(-1, dir);
				armLeft(-1-power, dir);
				}else if(checkValue < 0){
				error = (nMotorEncoder[right] - nMotorEncoder[left])/mEV;
				intrg += error * ((time1(T1) - lastTime) / mI);
				if(-100 < error && error < 100)
					intrg = 0;
				if(abs(intrg) <= mIV)
					intrg = mIV;
				power = error*mS - intrg;
				armLeft(-1, dir);
				armRight(-1-power, dir);
				}else {
				arm(-1,dir,1);
			}
			lastTime = time1(T1);
			break;
		}
	}

}

task main(){
sideOf colour = BLUE;
//extend claw
arm(1, UP, 200);		//raise arm
arm(1, DOWN, 200);	//lower arm

//1000 does 90 degree turn on regular tiled floor
//go to skyrise (45 degrees)
rotate(1, abs(RIGHT - colour) , rotVal);
	for(int i = 0; i < 4; i++){
		clawIntake(CLOSED);
		arm(1, UP, skyHgt + skyHgt*i );							//raise arm entire tower
		rotate(1, abs(LEFT - colour) , 2 * rotVal);	//rotate to skyrise tower
		arm(1, DOWN, skyHgt);										//lower arm to slot in skyrise
		clawIntake(OPEN);											//open claw to leave skyrise in tower
		arm(1, UP, skyHgt);											//raise arm to avoid skyrise
		rotate(1, abs(RIGHT - colour) , 2 * rotVal);//rotate to skyrise dropper
		arm(1, DOWN, skyHgt + skyHgt*i );						//lower claw to the skyrise dropper
	}

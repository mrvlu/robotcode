#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  ,               sensorDigitalOut)
#pragma config(Sensor, dgtl2,  ,               sensorDigitalOut)
#pragma config(Sensor, dgtl2,  ,               sensorDigitalOut)
#pragma config(Sensor, dgtl3,  skyriseClaw,    sensorDigitalOut)
#pragma config(Sensor, dgtl4,  cubeIntaKe,     sensorDigitalOut)
#pragma config(Sensor, I2C_1,  backLeftEnc,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  backRightEnc,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           botLeft,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           midLeft,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           midRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           topLeft,       tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port5,           topRight,      tmotorVex393_MC29, PIDControl, encoderPort, I2C_4)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port7,           frontLeft,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           backRight,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          botRight,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "autoSelector.h"
#include "states.h"
#include "arm.h"
#include "lcdDisplay.h"
#include "intakeControl.h"
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//const int fullPower = 127; //full speed

const int rotVal = 865;
const int zero = 0;
const int skyHgt = 450;
const int skyrise = 127; //for skyrise turn speed

void stopDrive(){
	motor[frontRight] = zero;
	motor[backRight] = zero;
	motor[backLeft] =  zero;
	motor[frontLeft] =  zero;

}
void encDrive(int x){
	nMotorEncoder[backRight] = x;
	nMotorEncoder[backLeft] = x;
	nMotorEncoder[frontRight] = x;
	nMotorEncoder[frontLeft] = x;

}


void drive(moveDir dir, int encoder){
	encDrive(0);
	while(abs(nMotorEncoder[backRight]) < encoder && abs(nMotorEncoder[backLeft]) < encoder){
		switch(dir){
		case FORWARDS:
			motor[frontRight] = fullPower;
			motor[backRight] = fullPower;
			motor[backLeft] = fullPower;
			motor[frontLeft] = fullPower;
			break;
		case RIGHT:
			motor[frontRight] = -fullPower;
			motor[backRight] = fullPower;
			motor[backLeft] = -fullPower;
			motor[frontLeft] = fullPower;
			break;
		case BACKWARDS:
			motor[frontRight] =  fullPower;
			motor[backRight] = fullPower;
			motor[backLeft] = fullPower;
			motor[frontLeft] = fullPower;
			break;
		case LEFT:
			motor[frontRight] = fullPower;
			motor[backRight] = -fullPower;
			motor[backLeft] = fullPower;
			motor[frontLeft] = -fullPower;
			break;
		}
	}
	stopDrive();
	wait1Msec(500);
}





//4106 //max pot values
//4180





void rotArm(int changeEnc, moveDir dirY, int encoder, armDir dirX){
//changeenc is for arm, encoder is for rotation
	encDrive(0);
	bool rotation = true;
	bool armHeight = true;
	while(armHeight && rotation){
		switch(dirY){
		case UP:
			if(nMotorEncoder[topLeft] < changeEnc && nMotorEncoder[topRight] < changeEnc){
				motor[botRight] = -fullPower;
				motor[botLeft] = -fullPower;
				motor[midRight] = -fullPower;
				motor[midLeft] = -fullPower;
				motor[topRight] = -fullPower;
				motor[topLeft] = -fullPower;
			}else{
				stopArm();
			}

			if(abs(nMotorEncoder[backRight]) < encoder && abs(nMotorEncoder[backLeft]) < encoder){		//
				switch(dirX){
				case LEFT:
					motor[frontRight] = -skyrise;
					motor[backRight] = -skyrise;
					motor[backLeft] =  skyrise;
					motor[frontLeft] =  skyrise;
					break;
				case RIGHT:
					motor[frontRight] =  skyrise;
					motor[backRight] = skyrise;
					motor[backLeft] = -skyrise;
					motor[frontLeft] = -skyrise;
					break;
				}
			}else{
				stopDrive();
			}
			break;
		case DOWN:
			if(nMotorEncoder[topLeft] > changeEnc && nMotorEncoder[topRight] > changeEnc){
				motor[botRight] = fullPower;
				motor[botLeft] =  fullPower;
				motor[midRight] =  fullPower;
				motor[midLeft] =  fullPower;
				motor[topRight] =  fullPower;
				motor[topLeft] =  fullPower;
			}else{
				stopArm();
			}

			if(abs(nMotorEncoder[backRight]) < encoder && abs(nMotorEncoder[backLeft]) < encoder){		//
				switch(dirX){
				case LEFT:
					motor[frontRight] = -skyrise;
					motor[backRight] = -skyrise;
					motor[backLeft] =  skyrise;
					motor[frontLeft] =  skyrise;
					break;
				case RIGHT:
					motor[frontRight] =  skyrise;
					motor[backRight] = skyrise;
					motor[backLeft] = -skyrise;
					motor[frontLeft] = -skyrise;
					break;
				}
			}else{
				stopDrive();
			}
			break;
		}

	}

	stopArm();
	wait1Msec(100);

}

void rotate(moveDir dir, int encoder){
	encDrive(0);
	while(abs(nMotorEncoder[backRight]) < encoder && abs(nMotorEncoder[backLeft]) < encoder){		//
		switch(dir){
		case LEFT:
			motor[frontRight] = -skyrise;
			motor[backRight] = -skyrise;
			motor[backLeft] =  skyrise;
			motor[frontLeft] =  skyrise;
			break;
		case RIGHT:
			motor[frontRight] =  skyrise;
			motor[backRight] = skyrise;
			motor[backLeft] = -skyrise;
			motor[frontLeft] = -skyrise;
			break;
		}
	}
	stopDrive();
	wait1Msec(100);
}

void skyriseAuto(sideOf colour){
	//starting point												//1000 does 90 degree turn on regular tiled floor
	encArm(0);
	arm(UP, skyHgt);
	clawIntake(OPEN);
	rotate(abs(LEFT - colour), 300);
	arm(DOWN, 0);
	//continous
	for(int i = 0; i < 6; i++){
		clawIntake(CLOSED);														//close claw to pickup skyrisea
		arm(UP, skyHgt*i + skyHgt);										//raise skyrise piece
		rotate(abs(RIGHT - colour),rotVal);                			//rotate towards skyrise
		arm(DOWN, nMotorEncoder[topLeft]  -skyHgt);		//moves arm down
		clawIntake(OPEN);
		arm(UP, nMotorEncoder[topLeft] + skyHgt);															//moves arm up
		rotate(abs(LEFT - colour), rotVal);
		arm(DOWN, 0);
	}
}

void cubeAuto(sideOf colour){
	arm(DOWN, 600); //picks up first cube
	arm(UP, 600); //sets arm in position pick up second cube
	drive(FORWARDS, 500); //moves forward to pick up second cube
	arm(DOWN, 600); //needles into second cube
	arm(UP, 600); //extends arm to pole height
	drive(FORWARDS, 500); // moves to align with pole
	rotate(abs(RIGHT - colour), 1000);
	drive(FORWARDS, 200); // moves toward pole and alligns intake with pole
	cube(OPEN);
}

/*task lcd(){
lcdDisplay();
}*/

task main(){
	//	startTask(lcd);
	skyriseAuto(RED);

	//cubeAuto(RED);
	//



}

#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  ,               sensorDigitalOut)
#pragma config(Sensor, dgtl2,  ,               sensorDigitalOut)
#pragma config(Sensor, dgtl3,  skyriseClaw,    sensorDigitalOut)
#pragma config(Sensor, dgtl4,  cubeIntaKe,     sensorDigitalOut)
#pragma config(Sensor, I2C_1,  backLeftEnc,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  backRightEnc,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           botLeft,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           midLeft,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           midRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           topLeft,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port5,           topRight,      tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port7,           frontLeft,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           backRight,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          botRight,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "states.h"
#include "pid.h"
#include "lcdDisplay.h"
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//const int fullPower = 127; //full speed
const int skyrise = 127; //for skyrise turn speed
const int rotVal = 1025;
const int zero = 0;
const int skyHgt = 450;

int bothEnc(){
return (nMotorEncoder[topLeft] -  nMotorEncoder[topRight]);

}




void stopDrive(){
	motor[frontRight] = zero;
	motor[backRight] = zero;
	motor[backLeft] =  zero;
	motor[frontLeft] =  zero;

}

void clawIntake(clawPos pos){
	switch(pos){
	case OPEN:
		SensorValue[skyriseClaw] = 0;
		break;
	case CLOSED:
		SensorValue[skyriseClaw] = 1;
		break;
	}
}

void cube(clawPos pos){
		switch(pos){
	case OPEN:
		SensorValue[cubeIntaKe] = 0;
		break;
	case CLOSED:
		SensorValue[cubeIntaKe] = 1;
		break;
	}
}
	



void drive(moveDir dir, int encoder){
	
	switch(dir){
	case FORWARDS:
		while(nMotorEncoder[backRight] < encoder && nMotorEncoder[backLeft] < encoder){
		motor[frontRight] = fullPower;
		motor[backRight] = fullPower;
		motor[backLeft] = fullPower;
		motor[frontLeft] = fullPower;
		}
		break;
	case RIGHT:
		int val = encoder - nMotorEncode[backLeft];
		while(nMotorEncoder[backRight] > encoder - val*2 && nMotorEncoder[backLeft] < encoder){
		motor[frontRight] = -fullPower;
		motor[backRight] = -fullPower;
		motor[backLeft] = fullPower;
		motor[frontLeft] = fullPower;
		}
		break;
	case BACKWARDS:
		while(nMotorEncoder[backRight] > encoder && nMotorEncoder[backLeft] > encoder){
		motor[frontRight] =  -fullPower;
		motor[backRight] = -fullPower;
		motor[backLeft] = -fullPower;
		motor[frontLeft] = -fullPower;
		}
	
		break;
	case LEFT:
		motor[frontRight] = fullPower;
		motor[backRight] = -fullPower;
		motor[backLeft] = fullPower;
		motor[frontLeft] = -fullPower;
		break;
	}
}
	stopDrive();
	wait1Msec(500);
}

void encDrive(int x){
	nMotorEncoder[backRight] = x;
	nMotorEncoder[backLeft] = x;
	nMotorEncoder[frontRight] = x;
	nMotorEncoder[frontLeft] = x;

}


void rotate(moveDir dir, int encoder){
	encDrive(0);
	while(abs(nMotorEncoder[backRight]) < encoder && abs(nMotorEncoder[backLeft]) < encoder){		//
		switch(dir){
		case LEFT:
			motor[frontRight] = -skyrise;
			motor[backRight] = -skyrise;
			motor[backLeft] =  skyrise;
			motor[frontLeft] =  skyrise;
			break;
		case RIGHT:
			motor[frontRight] =  skyrise;
			motor[backRight] = skyrise;
			motor[backLeft] = -skyrise;
			motor[frontLeft] = -skyrise;
			break;
		}
	}
	stopDrive();
	wait1Msec(500);
}


void intakeControl(clawPos pos) {
	switch(pos){
	case OPEN:
		SensorValue[cubeIntake] = 0;
		break;
	case CLOSED:
		SensorValue[cubeIntake] = 1;
		break;
	}
}

void cubeAuto(sideOf colour){
	switch(colour){
	case RED:
		arm(DOWN, 600); //picks up first cube
		arm(UP, 600); //sets arm in position pick up second cube
		drive(FORWARDS, 500); //moves forward to pick up second cube
		arm(DOWN, 600); //needles into second cube
		arm(UP, 600); //extends arm to pole height
		drive(FORWARDS, 500); // moves to align with pole
		rotate(RIGHT, 1000);
		drive(FORWARDS, 200); // moves toward pole and alligns intake with pole
		cube(OPEN);
		break;

	case BLUE:
		arm(DOWN, 600); //picks up first cube
		arm(UP, 600); //sets arm in position pick up second cube
		drive(FORWARDS, 500); //moves forward to pick up second cube
		arm(DOWN, 600); //needles into second cube
		arm(UP, 600); //extends arm to pole height
		drive(FORWARDS, 500); // moves to align with pole
		rotate(LEFT, 1000);
		drive(FORWARDS, 200); // moves toward pole and alligns intake with pole
		cube(OPEN);
		break;
	}

}

void skyriseAuto(sideOf colour){
	//pre												//1000 does 90 degree turn on regular tiled floor
	switch(colour){
	case RED:
		encArm(0);
		arm(UP, 350);
		rotate(RIGHT, 425);
		arm(DOWN, 0);

		for(int i = 0; i < 6; i++){
			clawIntake(CLOSED);														//close claw to pickup skyrisea
			arm(UP, skyHgt*i + skyHgt);										//raise skyrise piece
			rotate(LEFT,rotVal + 50);                			//rotate towards skyrise
			arm(DOWN, nMotorEncoder[topLeft]  - skyHgt);		//moves arm down
			clawIntake(OPEN);
			arm(UP, nMotorEncoder[topLeft] + skyHgt);															//moves arm up
			rotate(RIGHT, rotVal);
			arm(DOWN, 0);
		}
		break;
	case BLUE:
		encArm(0);
		arm(UP, 350);
		rotate(RIGHT, 425);
		arm(DOWN, 0);

		for(int i = 0; i < 6; i++){
			clawIntake(CLOSED);														//close claw to pickup skyrisea
			arm(UP, skyHgt*i + skyHgt);										//raise skyrise piece
			rotate(LEFT,rotVal + 50);                			//rotate towards skyrise
			arm(DOWN, nMotorEncoder[topLeft]  - skyHgt);		//moves arm down
			clawIntake(OPEN);
			arm(UP, nMotorEncoder[topLeft] + skyHgt);															//moves arm up
			rotate(RIGHT, rotVal);
			arm(DOWN, 0);
		}
		break;
		}
	}



	task main(){
		sideOf colour = BLUE; 												//color of platform;
		//cube or skyrise


	}

#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    rightPot,       sensorPotentiometer)
#pragma config(Sensor, in5,    autoSelect,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  cubeIntake,     sensorDigitalOut)
#pragma config(Sensor, dgtl2,  skyriseClaw,    sensorDigitalOut)
#pragma config(Sensor, dgtl3,  skyriseArm,     sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           botLeft,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           midLeft,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           midRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           topLeft,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           topRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port7,           frontLeft,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port8,           frontRight,    tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port9,           backRight,     tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port10,          botRight,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int fullPower = 127;
int error = 0;
int intrg = 0;		//integral
int mI = 1;			//integral multiplyer
int mS = 1			//speed multiplyer
int mIV = 0;		//maximum integral value
int mEV = 100;		//max encoder value
int lastTime = 0;	//last integral check

enum moveDir {
	FORWARDS,
	RIGHT,
	BACKWARDS,
	LEFT
};

enum armDir {
	UP,
	DOWN
};

enum clawPos {	//USED FOR BOTH SKYRISE AND CUBE INTAKE
	CLOSED,
	OPEN
};

enum skyArm{
	PICKUP,
	DROPOFF
};

void armControl(clawPos pos) {
	SensorValue[cubeIntake] = pos; //OPEN OR CLOSE
}
void skyriseArmControl(skyArm pos){	//PICKUP OR DROPOFF
	SensorValue[skyriseArm] = pos;
}

void drive(int power, moveDir dir){
  switch(dir){
    case FORWARDS:
      motor[frontRight] = fullPower * power;
      motor[backRight] = fullPower * power;
      motor[backLeft] = fullPower * power;
      motor[frontLeft] = fullPower * power;
      break;
    case RIGHT:
      motor[frontRight] = -fullPower * power;
      motor[backRight] = fullPower * power;
      motor[backLeft] = -fullPower * power;
      motor[frontLeft] = fullPower * power;
      break;
    case BACKWARDS:
      motor[frontRight] =  fullPower * power;
      motor[backRight] = fullPower * power
      motor[backLeft] = fullPower * power;
      motor[frontLeft] = fullPower * power;
      break;
    case LEFT:
      motor[frontRight] = fullPower * power;
      motor[backRight] = -fullPower * power;
      motor[backLeft] = fullPower * power;
      motor[frontLeft] = -fullPower * power;
      break;
  }
}

void arm(int power, armDir dir){
  switch(dir){
    case UP:
		//Left
		motor[topLeft] = fullPower * power;
		motor[midLeft] = fullPower * power;
		motor[botLeft] = fullPower * power;
		//Right
		motor[topRight] = fullPower * power;
		motor[botRight] = fullPower * power;
		motor[midRight] = fullPower * power;
		break;
    case DOWN:
		//Left
		motor[topLeft] = -fullPower * power;
		motor[midLeft] = -fullPower * power;
		motor[botLeft] = -fullPower * power;
		//Right
		motor[topRight] = -fullPower * power;
		motor[midRight] = -fullPower * power;
		motor[botRight] = -fullPower * power;
		break;
  }
}

void armLeft(int power, armDir dir){
  switch(dir){
    case UP:
		//Left
		motor[topLeft] = fullPower * power;
		motor[midLeft] = fullPower * power;
		motor[botLeft] = fullPower * power;
		break;
    case DOWN:
		//Left
		motor[topLeft] = -fullPower * power;
		motor[midLeft] = -fullPower * power;
		motor[botLeft] = -fullPower * power;
		break;
  }
}
void armRight(int power, armDir dir){
  switch(dir){
    case UP:
		//Right
		motor[topRight] = fullPower * power;
		motor[botRight] = fullPower * power;
		motor[midRight] = fullPower * power;
		break;
    case DOWN:
		//Right
		motor[topRight] = -fullPower * power;
		motor[midRight] = -fullPower * power;
		motor[botRight] = -fullPower * power;
		break;
  }
}


void rotate(int power, moveDir dir){ 
	switch(dir){
	case LEFT:
		motor[frontRight] = fullPower;
		motor[backRight] = fullPower;
		motor[backLeft] = -fullPower;
		motor[frontLeft] = -fullPower;
		break;
	case RIGHT:
		motor[frontRight] = -fullPower;
		motor[backRight] = -fullPower;
		motor[backLeft] = fullPower;
		motor[frontLeft] = fullPower;
		break;
	}
}

void encDrive(int x){

	nMotorEncoder[frontRight] = x;
	nMotorEncoder[backRight] = x;
	nMotorEncoder[backLeft] = x;
	nMotorEncoder[frontLeft] = x;
	}
void pidArm(armDir dir, int dist){
	//2 arm encoders
	lastTime = time1(T1);
	
	while(nMotorEncoder[left] >= dist &&nMotorEncoder[right] >= dist){
		int checkValue = nMotorEncoder[left] - nMotorEncoder[right];
		switch(dir){
			case UP:
				if(checkValue > 0){
					error = (nMotorEncoder[left] - nMotorEncoder[right])/mEV;
					intrg += error * ((time1(T1) - lastTime) / mI);
					if(error = 0)
						intrg = 0;
					if(abs(intrg) <= mIV)
						intrg = mIV;
					power = error*mS - intrg;
					armRight(1);
					armLeft(1-power);
				}else if(checkValue < 0){
					error = (nMotorEncoder[right] - nMotorEncoder[left])/mEV;
					intrg += error * ((time1(T1) - lastTime) / mI);
					if(error = 0)
						intrg = 0;
					if(abs(intrg) <= mIV)
						intrg = mIV;
					power = error*mS - intrg;
					armLeft(1);
					armRight(1-power);
				}else {
					arm(1,dir);
				}
				lastTime = time1(T1);
				break;
			case DOWN:
				checkValue *= -1;
				if(checkValue > 0){
					error = (nMotorEncoder[left] - nMotorEncoder[right])/mEV;
					intrg += error * ((time1(T1) - lastTime) / mI);
					if(error = 0)
						intrg = 0;
					if(abs(intrg) <= mIV)
						intrg = mIV;
					power = error*mS - intrg;
					armRight(-1);
					armLeft(-1-power);
				}else if(checkValue < 0){
					error = (nMotorEncoder[right] - nMotorEncoder[left])/mEV;
					intrg += error * ((time1(T1) - lastTime) / mI);
					if(error = 0)
						intrg = 0;
					if(abs(intrg) <= mIV)
						intrg = mIV;
					power = error*mS - intrg;
					armLeft(-1);
					armRight(-1-power);
				}else {
					arm(-1,dir);
				}
				lastTime = time1(T1);
				break;
		}
	}
}





task main(){

while(encoderDrive(0) < 500){
drive(1,FORWARDS);
}

}

#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    rightPot,       sensorPotentiometer)
#pragma config(Sensor, in5,    autoSelect,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  cubeIntake,     sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           botLeft,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           midLeft,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           midRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           topLeft,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           topRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port7,           frontLeft,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port8,           frontRight,    tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port9,           backRight,     tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port10,          botRight,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int chnl1 = 0, chnl4 = 0, chnl3 = 0, threshold = 10;
int fullPower = 127;

void deadZone() {
	//Joystick variables

	//Create deadzone for Channel 1
	if(abs(vexRT[Ch1]) > threshold) {
		chnl1 = vexRT[Ch1];
	}
	else {
		chnl1 = 0;
	}
	//Create deadzone for Channel 4
	if(abs(vexRT[Ch4]) > threshold) {
		chnl4 = vexRT[Ch4];
	}
	else {
		chnl4 = 0;
	}
	//Create deadzone for Channel 3
	if(abs(vexRT[Ch3]) > threshold) {
		chnl3 = vexRT[Ch3];
	}
	else {
		chnl3 = 0;
	}
}
void baseControl() {
	//Joystick control for driver
	motor[frontRight] = chnl3 + chnl1 + chnl4;
	motor[backRight] = chnl3 + chnl1 - chnl4;
	motor[backLeft] = chnl3 - chnl1 + chnl4;
	motor[frontLeft] = chnl3 - chnl1 - chnl4;

	if(vexRT[Btn6D] == 1) {
		motor[botRight] = fullPower;
		motor[botLeft] = fullPower;
		motor[midRight] = fullPower;
		motor[midLeft] = fullPower;
		motor[topRight] = fullPower;
		motor[topLeft] = fullPower;
	}
	else if(vexRT[Btn5D] == 1) {
		motor[botRight] = -fullPower;
		motor[botLeft] = -fullPower;
		motor[midRight] = -fullPower;
		motor[midLeft] = -fullPower;
		motor[topRight] = -fullPower;
		motor[topLeft] = -fullPower;
	}
	else {
		motor[botRight] = 0;
		motor[botLeft] = 0;
		motor[midRight] = 0;
		motor[midLeft] = 0;
		motor[topRight] = 0;
		motor[topLeft] = 0;
	}
}
void armControl() {
	if(vexRT[Btn6U] == 1) {
		SensorValue[cubeIntake] = 0;
	}
	else {
		SensorValue[cubeIntake] = 1;
	}
}

task main()
{

	//Driver control
	while (true) {

		deadZone();
		baseControl();
		armControl();

	}
}
